<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="4"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<rfc category="std" docName="draft-ietf-core-new-block-latest"
     ipr="trust200902">
  <front>
    <title abbrev="Quick Block-Wise Transfer Options">Constrained Application
    Protocol (CoAP) Block-Wise Transfer Options for Faster
    Transmission</title>

    <author fullname="Mohamed Boucadair" initials="M." surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street></street>

          <city>Rennes</city>

          <region></region>

          <code>35000</code>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <author fullname="Jon Shallow" initials="J." surname="Shallow">
      <organization></organization>

      <address>
        <postal>
          <street></street>

          <city></city>

          <region></region>

          <code></code>

          <country>United Kingdom</country>
        </postal>

        <email>supjps-ietf@jpshallow.com</email>
      </address>
    </author>

    <date />

    <workgroup>CoRE Working Group</workgroup>

    <keyword>Quick-Block</keyword>

    <keyword>Robust-Block</keyword>

    <keyword>R-Block</keyword>

    <keyword>Tough-Block</keyword>

    <keyword>Resilient-Block</keyword>

    <keyword>Fast-Block</keyword>

    <keyword>Resilience</keyword>

    <keyword>Filtering</keyword>

    <keyword>Faster transmission</keyword>

    <keyword>Large amounts of data</keyword>

    <keyword>Less packet interchange</keyword>

    <keyword>Fast recovery</keyword>

    <keyword>DOTS</keyword>

    <abstract>
      <t>This document specifies alternative Constrained Application Protocol
      (CoAP) Block-Wise transfer options: Q-Block1 and Q-Block2 Options.</t>

      <t>These options are similar to the CoAP Block1 and Block2 Options
      defined in RFC 7959, not a replacement for them, but do enable faster
      transmission rates for large amounts of data with less packet
      interchanges. Also, Q-Block1 and Q-Block2 Options support faster
      recovery should any of the blocks get lost in transmission.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="introduction" title="Introduction">
      <t>The Constrained Application Protocol (CoAP) <xref
      target="RFC7252"></xref>, although inspired by HTTP, was designed to use
      UDP instead of TCP. The message layer of CoAP over UDP includes support
      for reliable delivery, simple congestion control, and flow control.
      <xref target="RFC7959"></xref> introduced the CoAP Block1 and Block2
      Options to handle data records that cannot fit in a single IP packet, so
      not having to rely on IP fragmentation and was further updated by <xref
      target="RFC8323"></xref> for use over TCP, TLS, and WebSockets.</t>

      <t>The CoAP Block1 and Block2 Options work well in environments where
      there are no or minimal packet losses. These options operate
      synchronously, i.e., each individual block has to be requested. A CoAP
      endpoint can only ask for (or send) the next block when the transfer of
      the previous block has completed. Packet transmission rate, and hence
      block transmission rate, is controlled by Round Trip Times (RTTs).</t>

      <t>There is a requirement for these blocks of data to be transmitted at
      higher rates under network conditions where there may be asymmetrical
      transient packet loss (i.e., responses may get dropped). An example is
      when a network is subject to a Distributed Denial of Service (DDoS)
      attack and there is a need for DDoS mitigation agents relying upon CoAP
      to communicate with each other (e.g., <xref
      target="RFC8782"></xref><xref target="I-D.ietf-dots-telemetry"></xref>).
      As a reminder, <xref target="RFC7959"></xref> recommends the use of
      Confirmable (CON) responses to handle potential packet loss. However,
      such a recommendation does not work with a flooded pipe DDoS
      situation.</t>

      <t>This document introduces the CoAP Q-Block1 and Q-Block2 Options
      (<xref target="alt"></xref>).</t>
    </section>

    <section anchor="notation" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref><xref target="RFC8174"></xref> when, and
      only when, they appear in all capitals, as shown here.</t>

      <t>Readers should be familiar with the terms and concepts defined in
      <xref target="RFC7252"></xref>, <xref target="RFC7959"></xref>, and
      <xref target="RFC8132"></xref>.</t>

      <t>The terms "payload" and "body" are defined in <xref
      target="RFC7959"></xref>. The term "payload" is thus used for the
      content of a single CoAP message (i.e., a single block being
      transferred), while the term "body" is used for the entire resource
      representation that is being transferred in a block-wise fashion.</t>
    </section>

    <section anchor="alt" title="Alternative CoAP Block-Wise Transfer Options">
      <t>This document introduces the CoAP Q-Block1 and Q-Block2 Options.
      These options are similar in operation to the CoAP Block1 and Block2
      Options, respectively. They are not a replacement for them, but have the
      following benefits:</t>

      <t><list style="symbols">
          <t>They can operate in environments where packet loss is highly
          asymmetrical.</t>

          <t>They enable faster transmissions of sets of blocks of data with
          less packet interchanges.</t>

          <t>They support faster recovery should any of the blocks get lost in
          transmission.</t>

          <t>They support sending an entire body using Non-confirmable (NON)
          messages without requiring a response from the peer.</t>
        </list></t>

      <t>There are the following disadvantages over using CoAP Block1 and
      Block2 Options:<list style="symbols">
          <t>Loss of lock-stepping so payloads are not always received in the
          correct (block ascending) order.</t>

          <t>Additional congestion control measures need to be put in place
          for NON messages (<xref target="cc-non"></xref>).</t>

          <t>To reduce the transmission times for CON transmission of large
          bodies, NSTART needs to be increased from 1, but this affects
          congestion control where other parameters need to be tuned (Section
          4.7 of <xref target="RFC7252"></xref>). Such tuning is out of scope
          of this document.</t>

          <t>Mixing of NON and CON during requests/responses using Q-Block is
          not supported.</t>

          <t>The Q-Block Options do not support stateless operation/random
          access.</t>

          <t>Proxying of Q-Block is limited to caching full
          representations.</t>

          <t>There is no multicast support.</t>
        </list></t>

      <t>Q-Block1 and Q-Block2 Options are designed to work in particular with
      NON requests and responses.</t>

      <t>Using NON messages, the faster transmissions occur as all the blocks
      can be transmitted serially (as are IP fragmented packets) without
      having to wait for a response or next request from the remote CoAP peer.
      Recovery of missing blocks is faster in that multiple missing blocks can
      be requested in a single CoAP message. Even if there is asymmetrical
      packet loss, a body can still be sent and received by the peer whether
      the body comprises of a single or multiple payloads assuming no recovery
      is required.</t>

      <t>A CoAP endpoint can acknowledge all or a subset of the blocks.
      Concretely, the receiving CoAP endpoint either informs the CoAP sender
      endpoint of successful reception or reports on all blocks in the body
      that have not yet been received. The CoAP sender endpoint will then
      retransmit only the blocks that have been lost in transmission.</t>

      <t>Note that similar performance benefits can be applied to Confirmable
      messages if the value of NSTART is increased from 1 (Section 4.7 of
      <xref target="RFC7252"></xref>). However, the use of Confirmable
      messages will not work if there is asymmetrical packet loss. Some
      examples with Confirmable messages are provided in <xref
      target="CON"></xref>.</t>

      <t>There is little, if any, benefit of using these options with CoAP
      running over a reliable connection <xref target="RFC8323"></xref>. In
      this case, there is no differentiation between CON and NON as they are
      not used. Some examples using a reliable transport are provided in <xref
      target="REL"></xref>.</t>

      <t>Q-Block1 and Q-Block2 Options can be used instead of Block1 and
      Block2 Options when the different transmission properties are required.
      If the new options are not supported by a peer, then transmissions can
      fall back to using Block1 and Block2 Options (<xref
      target="prop"></xref>).</t>

      <t>The deviations from Block1 and Block2 Options are specified in <xref
      target="spec"></xref>. Pointers to appropriate <xref
      target="RFC7959"></xref> sections are provided.</t>

      <t>The specification refers to the base CoAP methods defined in Section
      5.8 of <xref target="RFC7252"></xref> and the new CoAP methods, FETCH,
      PATCH, and iPATCH introduced in <xref target="RFC8132"></xref>.</t>

      <t>The No-Response Option <xref target="RFC7967"></xref> was considered
      but was abandoned as it does not apply to Q-Block2 responses. A unified
      solution is defined in the document.</t>

      <section title="CoAP Response Code (4.08) Usage">
        <t>This document adds a media type for the 4.08 (Request Entity
        Incomplete) response defining an additional message format for
        reporting on payloads using the Q-Block1 Option that are not received
        by the server.</t>

        <t>See <xref target="code"></xref> for more details.</t>
      </section>

      <section anchor="scope" title="Applicability Scope">
        <t>The block-wise transfer specified in <xref target="RFC7959"></xref>
        covers the general case, but falls short in situations where packet
        loss is highly asymmetrical. The mechanism specified in this document
        provides roughly similar features to the Block1/Block2 Options. It
        provides additional properties that are tailored towards the intended
        use case of Non-Confirmable transmission. Concretely, this mechanism
        primarily targets applications such as DDoS Open Threat Signaling
        (DOTS) that cannot use CON responses to handle potential packet loss
        and that support application-specific mechanisms to assess whether the
        remote peer is able to handle the messages sent by a CoAP endpoint
        (e.g., DOTS heartbeats in Section 4.7 of <xref
        target="RFC8782"></xref>).</t>

        <t>The mechanism includes guards to prevent a CoAP agent from
        overloading the network by adopting an aggressive sending rate. These
        guards MUST be followed in addition to the existing CoAP congestion
        control as specified in Section 4.7 of <xref target="RFC7252"></xref>.
        See <xref target="cc"></xref> for more details.</t>

        <t>This mechanism is not intended for general CoAP usage, and any use
        outside the intended use case should be carefully weighed against the
        loss of interoperability with generic CoAP applications. It is hoped
        that the experience gained with this mechanism can feed future
        extensions of the block-wise mechanism that will both be generally
        applicable and serve this particular use case.</t>

        <t>It is not recommended that these options are used in a NoSec
        security mode (Section 9 of <xref target="RFC7252"></xref>) as the
        source endpoint needs to be trusted. Using OSCORE <xref
        target="RFC8613"></xref> does provide a security context and, hence, a
        trust of the source endpoint. However, using a NoSec security mode may
        still be inadequate for reasons discussed in <xref
        target="security"></xref>.</t>
      </section>
    </section>

    <section anchor="spec" title="The Q-Block1 and Q-Block2 Options">
      <section anchor="prop"
               title="Properties of Q-Block1 and Q-Block2 Options">
        <t>The properties of the Q-Block1 and Q-Block2 Options are shown in
        Table 1. The formatting of this table follows the one used in Table 4
        of <xref target="RFC7252"></xref> (Section 5.10). The C, U, N, and R
        columns indicate the properties Critical, UnSafe, NoCacheKey, and
        Repeatable defined in Section 5.4 of <xref target="RFC7252"></xref>.
        Only Critical and UnSafe columns are marked for the Q-Block1 Option.
        Critical, UnSafe, and Repeatable columns are marked for the Q-Block2
        Option. As these options are UnSafe, NoCacheKey has no meaning and so
        is marked with a dash.</t>

        <t><figure align="center">
            <artwork align="center"><![CDATA[+--------+---+---+---+---+--------------+--------+--------+---------+
| Number | C | U | N | R | Name         | Format | Length | Default |
+========+===+===+===+===+==============+========+========+=========+
|  TBA1  | x | x | - |   | Q-Block1     | uint   |  0-3   | (none)  |
|  TBA2  | x | x | - | x | Q-Block2     | uint   |  0-3   | (none)  |
+--------+---+---+---+---+--------------+--------+--------+---------+

      Table 1: CoAP Q-Block1 and Q-Block2 Option Properties
]]></artwork>
          </figure></t>

        <t>The Q-Block1 and Q-Block2 Options can be present in both the
        request and response messages. The Q-Block1 Option pertains to the
        request payload and the Q-Block2 Option pertains to the response
        payload. The Content-Format Option applies to the body, not to the
        payload (i.e., it must be the same for all payloads of the same
        body).</t>

        <t>Q-Block1 Option is useful with the payload-bearing POST, PUT,
        FETCH, PATCH, and iPATCH requests and their responses.</t>

        <t>Q-Block2 Option is useful with GET, POST, PUT, FETCH, PATCH, and
        iPATCH requests and their payload-bearing responses (2.01, 2.02, 2.03,
        2.04, and 2.05) (Section 5.5 of <xref target="RFC7252"></xref>).</t>

        <t>A CoAP endpoint (or proxy) MUST support either both or neither of
        the Q-Block1 and Q-Block2 Options.</t>

        <t>If Q-Block1 Option is present in a request or Q-Block2 Option in a
        response (i.e., in that message to the payload of which it pertains),
        it indicates a block-wise transfer and describes how this specific
        block-wise payload forms part of the entire body being transferred. If
        it is present in the opposite direction, it provides additional
        control on how that payload will be formed or was processed.</t>

        <t>To indicate support for Q-Block2 responses, the CoAP client MUST
        include the Q-Block2 Option in a GET or similar request, the Q-Block2
        Option in a PUT or similar request, or the Q-Block1 Option in a PUT or
        similar request so that the server knows that the client supports this
        Q-Block2 functionality should it need to send back a body that spans
        multiple payloads. Otherwise, the server would use the Block2 Option
        (if supported) to send back a message body that is too large to fit
        into a single IP packet <xref target="RFC7959"></xref>.</t>

        <t>Implementation of the Q-Block1 and Q-Block2 Options is intended to
        be optional. However, when it is present in a CoAP message, it MUST be
        processed (or the message rejected). Therefore, Q-Block1 and Q-Block2
        Options are identified as Critical options.</t>

        <t>With CoAP over UDP, the way a request message is rejected for
        critical options depends on the message type. A Confirmable message
        with an unrecognized critical option is rejected with a 4.02 (Bad
        Option) response (Section 5.4.1 of <xref target="RFC7252"></xref>). A
        Non-confirmable message with an unrecognized critical option is either
        rejected with a Reset message or just silently ignored (Sections 5.4.1
        and 4.3 of <xref target="RFC7252"></xref>). To reliably get a
        rejection message, it is therefore REQUIRED that clients use a
        Confirmable message for determining support for Q-Block1 and Q-Block2
        Options.</t>

        <t>The Q-Block1 and Q-Block2 Options are unsafe to forward. That is, a
        CoAP proxy that does not understand the Q-Block1 (or Q-Block2) Option
        MUST reject the request or response that uses either option.</t>

        <t>The Q-Block2 Option is repeatable when requesting retransmission of
        missing blocks, but not otherwise. Except that case, any request
        carrying multiple Q-Block1 (or Q-Block2) Options MUST be handled
        following the procedure specified in Section 5.4.5 of <xref
        target="RFC7252"></xref>.</t>

        <t>The Q-Block1 and Q-Block2 Options, like the Block1 and Block2
        Options, both of class E and class U for OSCORE processing (Table 2).
        The Q-Block1 (or Q-Block2) Option MAY be an Inner or Outer option
        (Section 4.1 of <xref target="RFC8613"></xref>). The Inner and Outer
        values are therefore independent of each other. The Inner option is
        encrypted and integrity protected between clients and servers, and
        provides message body identification in case of end-to-end
        fragmentation of requests. The Outer option is visible to proxies and
        labels message bodies in case of hop-by-hop fragmentation of
        requests.</t>

        <t><figure align="center">
            <artwork align="center"><![CDATA[                   +--------+-----------------+---+---+
                   | Number | Name            | E | U |
                   +========+=================+===+===+
                   |  TBA1  | Q-Block1        | x | x |
                   |  TBA2  | Q-Block2        | x | x |
                   +--------+-----------------+---+---+
       Table 2: OSCORE Protection of Q-Block1 and Q-Block2 Options
]]></artwork>
          </figure></t>

        <t></t>

        <t>Note that if Q-Block1 or Q-Block2 Options are included in a packet
        as Inner options, Block1 or Block2 Options MUST NOT be included as
        Inner options. Similarly there MUST NOT be a mix of Q-Block and Block
        for the Outer options. Messages that do not adhere with this behavior
        MUST be rejected with 4.02 (Bad Option). Q-Block and Block Options can
        be mixed across Inner and Outer options as these are handled
        independently of each other.</t>
      </section>

      <section title="Structure of Q-Block1 and Q-Block2 Options">
        <t>The structure of Q-Block1 and Q-Block2 Options follows the
        structure defined in Section 2.2 of <xref
        target="RFC7959"></xref>.</t>

        <t>There is no default value for the Q-Block1 and Q-Block2 Options.
        Absence of one of these options is equivalent to an option value of 0
        with respect to the value of block number (NUM) and more bit (M) that
        could be given in the option, i.e., it indicates that the current
        block is the first and only block of the transfer (block number is set
        to 0, M is unset). However, in contrast to the explicit value 0, which
        would indicate a size of the block (SZX) of 0, and thus a size value
        of 16 bytes, there is no specific explicit size implied by the absence
        of the option -- the size is left unspecified. (As for any uint, the
        explicit value 0 is efficiently indicated by a zero-length option;
        this, therefore, is different in semantics from the absence of the
        option).</t>
      </section>

      <section title="Using the Q-Block1 Option ">
        <t>The Q-Block1 Option is used when the client wants to send a large
        amount of data to the server using the POST, PUT, FETCH, PATCH, or
        iPATCH methods where the data and headers do not fit into a single
        packet.</t>

        <t>When Q-Block1 Option is used, the client MUST include a Request-Tag
        Option <xref target="I-D.ietf-core-echo-request-tag"></xref>. The
        Request-Tag value MUST be the same for all of the requests for the
        body of data that is being transferred. The Request-Tag is opaque, the
        server still treats it as opaque but the client MUST ensure that it is
        unique for every different body of transmitted data.<list
            style="empty">
            <t>Implementation Note: It is suggested that the client treats the
            Request-Tag as an unsigned integer of 8 bytes in length. An
            implementation may want to consider limiting this to 4 bytes to
            reduce packet overhead size. The initial Request-Tag value should
            be randomly generated and then subsequently incremented by the
            client whenever a new body of data is being transmitted between
            peers.</t>
          </list></t>

        <t><xref target="size"></xref> discusses the use of Size1 Option.</t>

        <t>For Confirmable transmission, the server continues to acknowledge
        each packet, but a response is not required (whether separate or
        piggybacked) until successful receipt of the body by the server. For
        Non-confirmable transmission, no response is required until the
        successful receipt of the body by the server or some of the payloads
        have not arrived after a timeout and a retransmit missing payloads
        response is needed. For reliable transports (e.g., <xref
        target="RFC8323"></xref>), a response is not required until successful
        receipt of the body by the server.</t>

        <t>Each individual payload of the body is treated as a new request
        (<xref target="token"></xref>).</t>

        <t>The client MUST send the payloads with the block numbers
        increasing, starting from zero, until the body is complete (subject to
        any congestion control (<xref target="cc"></xref>)). Any missing
        payloads requested by the server must in addition be separately
        transmitted with increasing block numbers.</t>

        <t>The following Response Codes are used:</t>

        <t>2.01 (Created)<list style="empty">
            <t>This Response Code indicates successful receipt of the entire
            body and that the resource was created. The token used SHOULD be
            from the last received payload. The client should then release all
            of the tokens used for this body. Note that the last received
            payload may not be the one with the highest block number.</t>
          </list></t>

        <t>2.02 (Deleted)<list style="empty">
            <t>This Response Code indicates successful receipt of the entire
            body and that the resource was deleted when using POST (Section
            5.8.2 <xref target="RFC7252"></xref>). The token used SHOULD be
            from the last received payload. The client should then release all
            of the tokens used for this body.</t>
          </list></t>

        <t>2.04 (Changed)<list style="empty">
            <t>This Response Code indicates successful receipt of the entire
            body and that the resource was updated. The token used SHOULD be
            from the last received payload. The client should then release all
            of the tokens used for this body.</t>
          </list></t>

        <t>2.05 (Content)<list style="empty">
            <t>This Response Code indicates successful receipt of the entire
            FETCH request body (Section 2 of <xref target="RFC8132"></xref>)
            and that the appropriate representation of the resource is being
            returned. The token used in the response SHOULD be from the last
            received payload.</t>

            <t>If the FETCH request includes the Observe Option, then the
            server MUST use the same token as used for the initial response
            for returning any Observe triggered responses so that the client
            can match them up.</t>

            <t>The client should then release all of the tokens used for this
            body unless a resource is being observed.</t>
          </list></t>

        <t>2.31 (Continue)<list style="empty">
            <t>This Response Code can be used to indicate that all of the
            blocks up to and including the Q-Block1 Option block NUM (all
            having the M bit set) have been successfully received. The token
            used SHOULD be from the last received payload.</t>

            <t>A response using this Response Code SHOULD NOT be generated for
            every received Q-Block1 Option request. It SHOULD only be
            generated when all the payload requests are Non-confirmable and a
            set of MAX_PAYLOADS (<xref target="cc-non"></xref>) payloads have
            been received by the server.</t>

            <t>It SHOULD NOT be generated for CON.</t>
          </list></t>

        <t>4.00 (Bad Request)<list style="empty">
            <t>This Response Code MUST be returned if the request does not
            include neither a Request-Tag Option nor a Size1 Option but does
            include a Q-Block1 option.</t>
          </list></t>

        <t>4.02 (Bad Option)<list style="empty">
            <t>Either this Response Code (in case of Confirmable request) or a
            reset message (in case of Non-confirmable request) MUST be
            returned if the server does not support the Q-Block Options.</t>
          </list></t>

        <t>4.08 (Request Entity Incomplete)<list style="empty">
            <t>As a reminder, this Response Code returned without Content-Type
            "application/missing-blocks+cbor-seq" (<xref
            target="new-format"></xref>) is handled as in Section 2.9.2 <xref
            target="RFC7959"></xref>.</t>

            <t>This Response Code returned with Content-Type
            "application/missing-blocks+cbor-seq" indicates that some of the
            payloads are missing and need to be resent. The client then
            retransmits the missing payloads using the same Request-Tag, Size1
            and Q-Block1 to specify the block NUM, SZX, and M bit as
            appropriate.</t>

            <t>The Request-Tag value to use is determined by taking the token
            in the 4.08 (Request Entity Incomplete) response, locating the
            matching client request, and then using its Request-Tag.</t>

            <t>The token used in the response SHOULD be from the last received
            payload. See <xref target="code"></xref> for further
            information.</t>

            <t>If the server has not received all the payloads of a body, but
            one or more NON payloads have been received, it SHOULD wait for up
            to NON_RECEIVE_TIMEOUT (<xref target="cc-non"></xref>) before
            sending a 4.08 (Request Entity Incomplete) response.</t>
          </list></t>

        <t>4.13 (Request Entity Too Large)<list style="empty">
            <t>This Response Code can be returned under similar conditions to
            those discussed in Section 2.9.3 of <xref
            target="RFC7959"></xref>.</t>

            <t>This Response Code can be returned if there is insufficient
            space to create a response PDU with a block size of 16 bytes (SZX
            = 0) to send back all the response options as appropriate. In this
            case, the Size1 Option is not included in the response.</t>
          </list></t>

        <t>Further considerations related to the transmission timings of 4.08
        (Request Entity Incomplete) and 2.31 (Continue) Response Codes are
        discussed in <xref target="cc-non"></xref>.</t>

        <t>If a server receives payloads with different Request-Tags for the
        same resource, it should continue to process all the bodies as it has
        no way of determining which is the latest version, or which body, if
        any, the client is terminating the transmission for.</t>

        <t>If the client elects to stop the transmission of a complete body,
        and absent any local policy, the client MUST "forget" all tracked
        tokens associated with the body's Request-Tag so that a reset message
        is generated for the invalid token in the 4.08 (Request Entity
        Incomplete) response. The server on receipt of the reset message
        SHOULD delete the partial body.</t>

        <t>If the server receives a duplicate block with the same Request-Tag,
        it MUST ignore the payload of the packet, but MUST still respond as if
        the block was received for the first time.</t>

        <t>A server SHOULD maintain a partial body (missing payloads) for up
        to NON_PARTIAL_TIMEOUT (<xref target="cc-non"></xref>).</t>
      </section>

      <section anchor="qblock2" title="Using the Q-Block2 Option">
        <t>In a request for any block number, the M bit unset indicates the
        request is just for that block. If the M bit is set, this has
        different meanings based on the NUM value:<list style="hanging">
            <t hangText="NUM is zero:">This is a request for the entire
            body.</t>

            <t
            hangText="'NUM modulo MAX_PAYLOADS' is zero, while NUM is not zero:">This
            is used to confirm that the current set of MAX_PAYLOADS payloads
            (the latest one having block number NUM-1) has been successfully
            received and that, upon receipt of this request, the server can
            continue to send the next set of payloads (the first one having
            block number NUM). This is the 'Continue' Q-Block-2 and
            conceptually has the same usage (i.e., continue sending the next
            set of data) as the use of 2.31 (Continue) for Q-Block1.</t>

            <t hangText="Any other value of NUM:">This is a request for that
            block and for all of the remaining blocks in the current
            MAX_PAYLOADS set.</t>
          </list></t>

        <t>If the request includes multiple Q-Block2 Options and these options
        overlap (e.g., combination of M being set (this and later blocks) and
        being unset (this individual block)) resulting in an individual block
        being requested multiple times, the server MUST only send back one
        instance of that block. This behavior is meant to prevent
        amplification attacks.</t>

        <t>The payloads sent back from the server as a response MUST all have
        the same ETag (Section 5.10.6 of <xref target="RFC7252"></xref>) for
        the same body. The server MUST NOT use the same ETag value for
        different representations of a resource.</t>

        <t>The ETag is opaque, the client still treats it as opaque but the
        server MUST ensure that it is unique for every different body of
        transmitted data.</t>

        <t><list style="empty">
            <t>Implementation Note: It is suggested that the server treats the
            ETag as an unsigned integer of 8 bytes in length. An
            implementation may want to consider limiting this to 4 bytes to
            reduce packet overhead size. The initial ETag value should be
            randomly generated and then subsequently incremented by the server
            whenever a new body of data is being transmitted between
            peers.</t>
          </list></t>

        <t><xref target="size"></xref> discusses the use of Size2 Option.</t>

        <t>The client may elect to request any detected missing blocks or just
        ignore the partial body. This decision is implementation specific.</t>

        <t>The client SHOULD wait for up to NON_RECEIVE_TIMEOUT (<xref
        target="cc-non"></xref>) after the last received payload for NON
        payloads before issuing a GET, POST, PUT, FETCH, PATCH, or iPATCH
        request that contains one or more Q-Block2 Options that define the
        missing blocks with the M bit unset. It is permissible to set the M
        bit to request this and later blocks from this MAX_PAYLOADS set.
        Further considerations related to the transmission timing for missing
        requests are discussed in <xref target="cc-non"></xref>.</t>

        <t>The requested missing block numbers MUST have an increasing block
        number in each additional Q-Block2 Option with no duplicates. The
        server SHOULD respond with a 4.00 (Bad Request) to requests not
        adhering to this behavior.</t>

        <t>For Confirmable responses, the client continues to acknowledge each
        packet. Typically, the server acknowledges the initial request using
        an ACK with the payload, and then sends the subsequent payloads as CON
        responses. The server will detect failure to send a packet, but the
        client can issue, after a MAX_TRANSMIT_SPAN delay, a separate GET,
        POST, PUT, FETCH, PATCH, or iPATCH for any missing blocks as
        needed.</t>

        <t>If the client receives a duplicate block with the same ETag, it
        MUST silently ignore the packet.</t>

        <t>A client SHOULD maintain a partial body (missing payloads) for up
        to NON_PARTIAL_TIMEOUT (<xref target="cc-non"></xref>) or as defined
        by the Max-Age Option (or its default of 60 seconds (Section 5.6.1 of
        <xref target="RFC7252"></xref>)), whichever is the less. On release of
        the partial body, the client should then release all of the tokens
        used for this body unless a resource is being observed.</t>

        <t>The ETag Option should not be used in the request for missing
        blocks as the server could respond with a 2.03 (Valid) response with
        no payload. It can be used in the request if the client wants to check
        the freshness of the locally cached body response.</t>

        <t>It is RECOMMENDED that the server maintains a cached copy of the
        body when using the Q-Block2 Option to facilitate retransmission of
        any missing payloads.</t>

        <t>If the server detects part way through a body transfer that the
        resource data has changed and the server is not maintaining a cached
        copy of the old data, then the transmission is terminated. Any
        subsequent missing block requests MUST be responded to using the
        latest ETag and Size2 Option values with the updated data.</t>

        <t>If the server responds during a body update with a different ETag
        Option value (as the resource representation has changed), then the
        client should treat the partial body with the old ETag as no longer
        being fresh.</t>

        <t>If the server transmits a new body of data (e.g., a triggered
        Observe notification) with a new ETag to the same client as an
        additional response, the client should remove any partially received
        body held for a previous ETag for that resource as it is unlikely the
        missing blocks can be retrieved.</t>

        <t>If there is insufficient space to create a response PDU with a
        block size of 16 bytes (SZX = 0) to send back all the response options
        as appropriate, a 4.13 (Request Entity Too Large) is returned without
        the Size1 Option.</t>
      </section>

      <section title="Using Observe Option">
        <t>For a request that uses Q-Block1, the Observe value <xref
        target="RFC7641"></xref> MUST be the same for all the payloads of the
        same body. This includes any missing payloads that are
        retransmitted.</t>

        <t>For a response that uses Q-Block2, the Observe value MUST be the
        same for all the payloads of the same body. This includes payloads
        transmitted following receipt of the 'Continue' Q-Block2 Option (<xref
        target="qblock2"></xref>) by the server. If a missing payload is
        requested, then both the request and response MUST NOT include the
        Observe Option.</t>
      </section>

      <section anchor="size" title="Using Size1 and Size2 Options">
        <t>Section 4 of <xref target="RFC7959"></xref> defines two CoAP
        options: Size1 for indicating the size of the representation
        transferred in requests and Size2 for indicating the size of the
        representation transferred in responses.</t>

        <t>The Size1 or Size2 option values MUST exactly represent the size of
        the data on the body so that any missing data can easily be
        determined.</t>

        <t>The Size1 Option MUST be used with the Q-Block1 Option when used in
        a request and MUST be present in all payloads of the request
        preserving the same value. The Size2 Option MUST be used with the
        Q-Block2 Option when used in a response and MUST be present in all
        payloads of the response preserving the same value.</t>
      </section>

      <section title="Using Q-Block1 and Q-Block2 Options Together">
        <t>The behavior is similar to the one defined in Section 3.3 of <xref
        target="RFC7959"></xref> with Q-Block1 substituted for Block1 and
        Q-Block2 for Block2.</t>
      </section>

      <section title="Using Q-Block2 Option With Multicast">
        <t>Servers MUST ignore multicast requests that contain the Q-Block2
        Option. As a reminder, Block2 Option can be used as stated in Section
        2.8 of <xref target="RFC7959"></xref>.</t>
      </section>
    </section>

    <section anchor="code"
             title="The Use of 4.08 (Request Entity Incomplete) Response Code">
      <t>4.08 (Request Entity Incomplete) Response Code has a new Content-Type
      "application/missing-blocks+cbor-seq" used to indicate that the server
      has not received all of the blocks of the request body that it needs to
      proceed. Such messages must not be treated by the client as a fatal
      error.</t>

      <t>Likely causes are the client has not sent all blocks, some blocks
      were dropped during transmission, or the client has sent them
      sufficiently long ago that the server has already discarded them.</t>

      <t>The data payload of the 4.08 (Request Entity Incomplete) response is
      encoded as a CBOR Sequence <xref target="RFC8742"></xref>. It comprises
      of one or more missing block numbers encoded as CBOR unsigned integers
      <xref target="RFC8949"></xref>. The missing block numbers MUST be unique
      in each 4.08 (Request Entity Incomplete) response when created by the
      server; the client MUST ignore any duplicates in the same 4.08 (Request
      Entity Incomplete) response.</t>

      <t>The Content-Format Option (Section 5.10.3 of <xref
      target="RFC7252"></xref>) MUST be used in the 4.08 (Request Entity
      Incomplete) response. It MUST be set to
      "application/missing-blocks+cbor-seq" (<xref
      target="new-format"></xref>).</t>

      <t>The Concise Data Definition Language <xref target="RFC8610"></xref>
      (and see Section 4.1 <xref target="RFC8742"></xref>) for the data
      describing these missing blocks is as follows:</t>

      <figure align="center" anchor="cddl"
              title="Structure of the Missing Blocks Payload">
        <artwork align="center"><![CDATA[; A notional array, the elements of which are to be used
; in a CBOR Sequence:
payload = [+ missing-block-number]
; A unique block number not received:
missing-block-number = uint
]]></artwork>
      </figure>

      <t></t>

      <t>The token to use for the response SHOULD be the token that was used
      in the last block number received so far with the same Request-Tag
      value. Note that the use of any received token with the same Request-Tag
      would be acceptable, but providing the one used in the last received
      payload will aid any troubleshooting. The client will use the token to
      determine what was the previously sent request to obtain the Request-Tag
      value to be used.</t>

      <t>If the size of the 4.08 (Request Entity Incomplete) response packet
      is larger than that defined by Section 4.6 <xref
      target="RFC7252"></xref>, then the number of missing blocks MUST be
      limited so that the response can fit into a single packet. If this is
      the case, then the server can send subsequent 4.08 (Request Entity
      Incomplete) responses containing the missing other blocks on receipt of
      a new request providing a missing payload with the same Request-Tag.</t>

      <t>The missing blocks MUST be reported in ascending order without any
      duplicates. The client SHOULD silently drop 4.08 (Request Entity
      Incomplete) responses not adhering with this behavior.</t>

      <t><list style="hanging">
          <t hangText="Implementation Note:">Consider limiting the number of
          missing payloads to MAX_PAYLOADS to minimize congestion control
          being needed. The CBOR sequence does not include any array
          wrapper.</t>
        </list></t>

      <t>The 4.08 (Request Entity Incomplete) with Content-Type
      "application/missing-blocks+cbor-seq" SHOULD NOT be used when using
      Confirmable requests or a reliable connection <xref
      target="RFC8323"></xref> as the client will be able to determine that
      there is a transmission failure of a particular payload and hence that
      the server is missing that payload.</t>
    </section>

    <section anchor="token" title="The Use of Tokens">
      <t>Each new request generally uses a new Token (and sometimes must, see
      Section 4 of <xref target="I-D.ietf-core-echo-request-tag"></xref>).
      Additional responses to a request all use the token of the request they
      respond to.</t>

      <t><list style="hanging">
          <t hangText="Implementation Note:">By using 8-byte tokens, it is
          possible to easily minimize the number of tokens that have to be
          tracked by clients, by keeping the bottom 32 bits the same for the
          same body and the upper 32 bits containing the current body's
          request number (incrementing every request, including every
          re-transmit). This allows the client to be alleviated from keeping
          all the per-request-state, e.g., in Section 3 of <xref
          target="RFC8974"></xref>.</t>
        </list></t>
    </section>

    <section anchor="cc" title="Congestion Control for Unreliable Transports">
      <t>The transmission of the payloads of a body over an unreliable
      transport MUST either all be Confirmable or all be Non-confirmable. This
      is meant to simplify the congestion control procedure.</t>

      <t>As a reminder, there is no need for CoAP-specific congestion control
      for reliable transports <xref target="RFC8323"></xref>.</t>

      <section anchor="cc-con" title="Confirmable (CON)">
        <t>Congestion control for CON requests and responses is specified in
        Section 4.7 of <xref target="RFC7252"></xref>. For faster transmission
        rates, NSTART will need to be increased from 1. However, the other CON
        congestion control parameters will need to be tuned to cover this
        change. This tuning is out of scope of this document as it is expected
        that all requests and responses using Q-Block1 and Q-Block2 will be
        Non-confirmable (<xref target="scope"></xref>).</t>

        <t>It is implementation specific as to whether there should be any
        further requests for missing data as there will have been significant
        transmission failure as individual payloads will have failed after
        MAX_TRANSMIT_SPAN.</t>
      </section>

      <section anchor="cc-non" title="Non-confirmable (NON)">
        <t>This document introduces new parameters MAX_PAYLOADS, NON_TIMEOUT,
        NON_RECEIVE_TIMEOUT, NON_MAX_RETRANSMIT, NON_PROBING_WAIT, and
        NON_PARTIAL_TIMEOUT primarily for use with NON (Table 3).</t>

        <t>MAX_PAYLOADS should be configurable with a default value of 10.
        Both CoAP endpoints SHOULD have the same value (otherwise there will
        be transmission delays in one direction) and the value MAY be
        negotiated between the endpoints to a common value by using a higher
        level protocol (out of scope of this document). This is the maximum
        number of payloads that can be transmitted at any one time.<list
            style="empty">
            <t>Note: The default value of 10 is chosen for reasons similar to
            those discussed in Section 5 of <xref
            target="RFC6928"></xref>.</t>
          </list></t>

        <t>NON_TIMEOUT is the maximum period of delay between sending sets of
        MAX_PAYLOADS payloads for the same body. By default, NON_TIMEOUT has
        the same value as ACK_TIMEOUT (Section 4.8 of <xref
        target="RFC7252"></xref>).</t>

        <t>NON_RECEIVE_TIMEOUT is the initial maximum time to wait for a
        missing payload before requesting retransmission for the first time.
        Every time the missing payload is re-requested, the time to wait value
        doubles. The time to wait is calculated as:<list style="empty">
            <t>Time-to-Wait = NON_RECEIVE_TIMEOUT * (2 ** (Re-Request-Count -
            1))</t>
          </list></t>

        <t>NON_RECEIVE_TIMEOUT has a default value of twice NON_TIMEOUT.
        NON_RECEIVE_TIMEOUT MUST always be greater than NON_TIMEOUT by at
        least one second so that the sender of the payloads has the
        opportunity to start sending the next set of payloads before the
        receiver times out.</t>

        <t>NON_MAX_RETRANSMIT is the maximum number of times a request for the
        retransmission of missing payloads can occur without a response from
        the remote peer. After this occurs, the local endpoint SHOULD consider
        the body stale, remove any body, and release Tokens and Request-Tag on
        the client (or the ETag on the server). By default, NON_MAX_RETRANSMIT
        has the same value as MAX_RETRANSMIT (Section 4.8 of <xref
        target="RFC7252"></xref>).</t>

        <t>NON_PROBING_WAIT is used to limit the potential wait needed
        calculated when using PROBING_WAIT. NON_PROBING_WAIT has the same
        value as computed for EXCHANGE_LIFETIME (Section 4.8.2 of <xref
        target="RFC7252"></xref>).</t>

        <t>NON_PARTIAL_TIMEOUT is used for expiring partially received bodies.
        NON_PARTIAL_TIMEOUT has the same value as computed for
        EXCHANGE_LIFETIME (Section 4.8.2 of <xref
        target="RFC7252"></xref>).</t>

        <t><figure align="center">
            <artwork align="center"><![CDATA[+---------------------+---------------+
| Parameter Name      | Default Value |
+=====================+===============|
| MAX_PAYLOADS        |            10 |
| NON_MAX_RETRANSMIT  |             4 |
| NON_TIMEOUT         |           2 s |
| NON_RECEIVE_TIMEOUT |           4 s |
| NON_PROBING_WAIT    |         247 s |
| NON_PARTIAL_TIMEOUT |         247 s |
+---------------------+---------------+

Table 3: Congestion Control Parameters]]></artwork>
          </figure></t>

        <t>PROBING_RATE parameter in CoAP indicates the average data rate that
        must not be exceeded by a CoAP endpoint in sending to a peer endpoint
        that does not respond. The single body of blocks will be subjected to
        PROBING_RATE (Section 4.7 of <xref target="RFC7252"></xref>), not the
        individual packets. If the wait time between sending bodies that are
        not being responded to based on PROBING_RATE exceeds NON_PROBING_WAIT,
        then the gap time is limited to NON_PROBING_WAIT.<list style="empty">
            <t>Note: For the particular DOTS application, PROBING_RATE and
            other transmission parameters are negotiated between peers. Even
            when not negotiated, the DOTS application uses customized defaults
            as discussed in Section 4.5.2 of <xref target="RFC8782"></xref>.
            Note that MAX_PAYLOADS, NON_MAX_RETRANSMIT, and NON_TIMEOUT can be
            negotiated between DOTS peers as per <xref
            target="I-D.bosh-dots-quick-blocks"></xref>.</t>
          </list>Each NON 4.08 (Request Entity Incomplete) response is subject
        to PROBING_RATE.</t>

        <t>Each NON GET or FETCH request using Q-Block2 Option is subject to
        PROBING_RATE.</t>

        <t>As the sending of many payloads of a single body may itself cause
        congestion, it is RECOMMENDED that after transmission of every set of
        MAX_PAYLOADS payloads of a single body, a delay is introduced of
        NON_TIMEOUT before sending the next set of payloads to manage
        potential congestion issues.</t>

        <t>If the CoAP peer reports at least one payload has not arrived for
        each body for at least a 24 hour period and it is known that there are
        no other network issues over that period, then the value of
        MAX_PAYLOADS can be reduced by 1 at a time (to a minimum of 1) and the
        situation re-evaluated for another 24 hour period until there is no
        report of missing payloads under normal operating conditions. The
        newly derived value for MAX_PAYLOADS should be used for both ends of
        this particular CoAP peer link. Note that the CoAP peer will not know
        about the MAX_PAYLOADS change until it is reconfigured. As a
        consequence of the two peers having different MAX_PAYLOADS values, a
        peer may continue indicate that there are some missing payloads as all
        of its MAX_PAYLOADS set may not have arrived. How the two peer values
        for MAX_PAYLOADS are synchronized is out of the scope.</t>

        <t>The sending of a set of missing payloads of a body is subject to
        MAX_PAYLOADS set of payloads.</t>

        <t>For Q-Block1 Option, if the server responds with a 2.31 (Continue)
        Response Code for the latest payload sent, then the client can
        continue to send the next set of payloads without any delay. If the
        server responds with a 4.08 (Request Entity Incomplete) Response Code,
        then the missing payloads SHOULD be retransmitted before going into
        another NON_TIMEOUT delay prior to sending the next set of
        payloads.</t>

        <t>For the server receiving NON Q-Block1 requests, it SHOULD send back
        a 2.31 (Continue) Response Code on receipt of all of the MAX_PAYLOADS
        payloads to prevent the client unnecessarily delaying. Otherwise the
        server SHOULD delay for NON_RECEIVE_TIMEOUT (exponentially scaled
        based on the repeat request count for a payload), before sending the
        4.08 (Request Entity Incomplete) Response Code for the missing
        payload(s). If this is a repeat for the 2.31 (Continue) response, the
        server SHOULD send a 4.08 (Request Entity Incomplete) response
        detailing the missing payloads after the block number that would have
        been indicated in the 2.31 (Continue). If the repeat request count for
        a missing payload exceeds NON_MAX_RETRANSMIT, the server SHOULD
        discard the partial body and stop requesting the missing payloads.</t>

        <t>It is likely that the client will start transmitting the next set
        of MAX_PAYLOADS payloads before the server times out on waiting for
        the last of the previous MAX_PAYLOADS payloads. On receipt of the
        first payload from the new set of MAX_PAYLOADS payloads, the server
        SHOULD send a 4.08 (Request Entity Incomplete) Response Code
        indicating any missing payloads from any previous MAX_PAYLOADS
        payloads. Upon receipt of the 4.08 (Request Entity Incomplete)
        Response Code, the client SHOULD send the missing payloads before
        continuing to send the remainder of the MAX_PAYLOADS payloads and then
        go into another NON_TIMEOUT delay prior to sending the next set of
        payloads.</t>

        <t>For the client receiving NON Q-Block2 responses, it SHOULD send a
        'Continue' Q-Block2 request (<xref target="qblock2"></xref>) for the
        next set of payloads on receipt of all of the MAX_PAYLOADS payloads to
        prevent the server unnecessarily delaying. Otherwise the client SHOULD
        delay for NON_RECEIVE_TIMEOUT (exponentially scaled based on the
        repeat request count for a payload), before sending the request for
        the missing payload(s). If the repeat request count for a missing
        payload exceeds NON_MAX_RETRANSMIT, the client SHOULD discard the
        partial body and stop requesting the missing payloads.</t>

        <t>The server SHOULD recognize the 'Continue' Q-Block2 request as a
        continue request and just continue the transmission of the body
        (including Observe Option, if appropriate for an unsolicited response)
        rather than as a request for the remaining missing blocks.</t>

        <t>It is likely that the server will start transmitting the next set
        of MAX_PAYLOADS payloads before the client times out on waiting for
        the last of the previous MAX_PAYLOADS payloads. Upon receipt of the
        first payload from the new set of MAX_PAYLOADS payloads, the client
        SHOULD send a request indicating any missing payloads from any
        previous set of MAX_PAYLOADS payloads. Upon receipt of such request,
        the server SHOULD send the missing payloads before continuing to send
        the remainder of the MAX_PAYLOADS payloads and then go into another
        NON_TIMEOUT delay prior to sending the next set of payloads.</t>

        <t>The client does not need to acknowledge the receipt of the entire
        body.</t>

        <t><list style="empty">
            <t>Note: If there is asymmetric traffic loss causing responses to
            never get received, a delay of NON_TIMEOUT after every
            transmission of MAX_PAYLOADS blocks will be observed. The endpoint
            receiving the body is still likely to receive the entire body.</t>
          </list></t>
      </section>
    </section>

    <section title="Caching Considerations">
      <t>Caching block based information is not straight forward in a proxy.
      For Q-Block1 and Q-Block2 Options, for simplicity it is expected that
      the proxy will reassemble the body (using any appropriate recovery
      options for packet loss) before passing on the body to the appropriate
      CoAP endpoint. This does not preclude an implementation doing a more
      complex per payload caching, but how to do this is out of the scope of
      this document. The onward transmission of the body does not require the
      use of the Q-Block1 or Q-Block2 Options as these options may not be
      supported in that link. This means that the proxy must fully support the
      Q-Block1 and Q-Block2 Options.</t>

      <t>How the body is cached in the CoAP client (for Q-Block1
      transmissions) or the CoAP server (for Q-Block2 transmissions) is
      implementation specific.</t>

      <t>As the entire body is being cached in the proxy, the Q-Block1 and
      Q-Block2 Options are removed as part of the block assembly and thus do
      not reach the cache.</t>

      <t>For Q-Block2 responses, the ETag Option value is associated with the
      data (and onward transmitted to the CoAP client), but is not part of the
      cache key.</t>

      <t>For requests with Q-Block1 Option, the Request-Tag Option is
      associated with the build up of the body from successive payloads, but
      is not part of the cache key. For the onward transmission of the body
      using CoAP, a new Request-Tag SHOULD be generated and used. Ideally this
      new Request-Tag should replace the client's request Request-Tag.</t>

      <t>It is possible that two or more CoAP clients are concurrently
      updating the same resource through a common proxy to the same CoAP
      server using Q-Block1 (or Block1) Option. If this is the case, the first
      client to complete building the body causes that body to start
      transmitting to the CoAP server with an appropriate Request-Tag value.
      When the next client completes building the body, any existing partial
      body transmission to the CoAP server is terminated and the new body
      representation transmission starts with a new Request-Tag value. Note
      that it cannot be assumed that the proxy will always receive a complete
      body from a client.</t>

      <t>A proxy that supports Q-Block2 Option MUST be prepared to receive a
      GET or similar request indicating one or more missing blocks. The proxy
      will serve from its cache the missing blocks that are available in its
      cache in the same way a server would send all the appropriate Q-Block2
      responses. If the cache key matching body is not available in the cache,
      the proxy MUST request the entire body from the CoAP server using the
      information in the cache key.</t>

      <t>How long a CoAP endpoint (or proxy) keeps the body in its cache is
      implementation specific (e.g., it may be based on Max-Age).</t>
    </section>

    <section title="HTTP-Mapping Considerations">
      <t>As a reminder, the basic normative requirements on HTTP/CoAP mappings
      are defined in Section 10 of <xref target="RFC7252"></xref>. The
      implementation guidelines for HTTP/CoAP mappings are elaborated in <xref
      target="RFC8075"></xref>.</t>

      <t>The rules defined in Section 5 of <xref target="RFC7959"></xref> are
      to be followed.</t>
    </section>

    <section title="Examples with Non-confirmable Messages">
      <t>This section provides some sample flows to illustrate the use of
      Q-Block1 and Q-Block2 Options with NON. Examples with CON are provided
      in <xref target="CON"></xref>.</t>

      <t>The examples in the following subsections assume MAX_PAYLOADS is set
      to 10 and NON_MAX_RETRANSMIT is set to 4.</t>

      <t><xref target="legend"></xref> lists the conventions that are used in
      the following subsections.</t>

      <t><figure align="center" anchor="legend"
          title="Notations Used in the Figures">
          <artwork align="center"><![CDATA[        T: Token value
        O: Observe Option value
        M: Message ID
       RT: Request-Tag
       ET: ETag
      QB1: Q-Block1 Option values NUM/More/SZX
      QB2: Q-Block2 Option values NUM/More/SZX
        \: Trimming long lines
     [[]]: Comments
     -->X: Message loss (request)
     X<--: Message loss (response)
      ...: Passage of time
Payload N: Corresponds to the CoAP message that conveys 
           a block number N-1 of a given block-wise
           exchange.
]]></artwork>
        </figure></t>

      <section title="Q-Block1 Option ">
        <section title="A Simple Example">
          <t><xref target="B3non"></xref> depicts an example of a NON PUT
          request conveying Q-Block1 Option. All the blocks are received by
          the server.</t>

          <t><figure anchor="B3non"
              title="Example of NON Request with Q-Block1 Option (Without Loss)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| NON PUT /path M:0x81 T:0xc0 RT=9 QB1:0/1/1024
         +--------->| NON PUT /path M:0x82 T:0xc1 RT=9 QB1:1/1/1024
         +--------->| NON PUT /path M:0x83 T:0xc2 RT=9 QB1:2/1/1024
         +--------->| NON PUT /path M:0x84 T:0xc3 RT=9 QB1:3/0/1024
         |<---------+ NON 2.04 M:0xf1 T:0xc3
         |   ...    |
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling MAX_PAYLOADS Limits">
          <t><xref target="B3non0"></xref> depicts an example of a NON PUT
          request conveying Q-Block1 Option. The number of payloads exceeds
          MAX_PAYLOADS. All the blocks are received by the server.</t>

          <t><figure anchor="B3non0"
              title="Example of MAX_PAYLOADS NON Request with Q-Block1 Option (Without Loss)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| NON PUT /path M:0x01 T:0xf1 RT=10 QB1:0/1/1024
         +--------->| NON PUT /path M:0x02 T:0xf2 RT=10 QB1:1/1/1024
         +--------->| [[Payloads 3 - 9 not detailed]]
         +--------->| NON PUT /path M:0x0a T:0xfa RT=10 QB1:9/1/1024
      [[MAX_PAYLOADS has been reached]]
         |     [[MAX_PAYLOADS blocks receipt acknowledged by server]]
         |<---------+ NON 2.31 M:0x81 T:0xfa
         +--------->| NON PUT /path M:0x0b T:0xfb RT=10 QB1:10/0/1024
         |<---------+ NON 2.04 M:0x82 T:0xfb
         |   ...    |
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling MAX_PAYLOADS with Recovery">
          <t>Consider now a scenario where a new body of data is to be sent by
          the client, but some blocks are dropped in transmission as
          illustrated in <xref target="B3non1"></xref>.</t>

          <t><figure anchor="B3non1"
              title="Example of MAX_PAYLOADS NON Request with Q-Block1 Option (With Loss)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| NON PUT /path M:0x11 T:0xe1 RT=11 QB1:0/1/1024
         +--->X     | NON PUT /path M:0x12 T:0xe2 RT=11 QB1:1/1/1024
         +--------->| [[Payloads 3 - 8 not detailed]]
         +--------->| NON PUT /path M:0x19 T:0xe9 RT=11 QB1:8/1/1024
         +--->X     | NON PUT /path M:0x1a T:0xea RT=11 QB1:9/1/1024
      [[MAX_PAYLOADS has been reached]]
         |   ...    |
      [[NON_TIMEOUT (client) delay expires]]
         |     [[Client starts sending next set of payloads]]
         +--->X     | NON PUT /path M:0x1b T:0xeb RT=11 QB1:10/1/1024
         +--------->| NON PUT /path M:0x1c T:0xec RT=11 QB1:11/1/1024
         |          |
]]></artwork>
            </figure></t>

          <t>On seeing a payload from the next set of payloads, the server
          realizes that some blocks are missing from the previous MAX_PAYLOADS
          payloads and asks for the missing blocks in one go (<xref
          target="B3non2"></xref>). It does so by indicating which blocks from
          the previous MAX_PAYLOADS payloads have not been received in the
          data portion of the response. The token used in the response should
          be the token that was used in the last received payload. The client
          can then derive the Request-Tag by matching the token with the sent
          request.</t>

          <t><figure anchor="B3non2"
              title="Example of NON Request with Q-Block1 Option (Blocks Recovery)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         |<---------+ NON 4.08 M:0x91 T:0xec [Missing 1,9]
         |     [[Client responds with missing payloads]]
         +--------->| NON PUT /path M:0x1d T:0xed RT=11 QB1:1/1/1024
         +--------->| NON PUT /path M:0x1e T:0xee RT=11 QB1:9/1/1024
         |     [[Client continues sending next set of payloads]]
         +--------->| NON PUT /path M:0x1f T:0xef RT=11 QB1:12/0/1024
         |   ...    |
      [[NON_RECEIVE_TIMEOUT (server) delay expires]]
         |     [[The server realizes a block is still missing and asks
         |        for the missing one]]            
         |<---------+ NON 4.08 M:0x92 T:0xef [Missing 10]
         +--------->| NON PUT /path M:0x20 T:0xf0 RT=11 QB1:10/1/1024
         |<---------+ NON 2.04 M:0x93 T:0xf0
         |   ...    |
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling Recovery with Failure">
          <t><xref target="B3non3"></xref> depicts an example of a NON PUT
          request conveying Q-Block1 Option where recovery takes place, but
          eventually fails.</t>

          <t><figure anchor="B3non3"
              title="Example of NON Request with Q-Block1 Option (With Eventual Failure)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| NON PUT /path M:0x91 T:0xd0 RT=12 QB1:0/1/1024
         +--->X     | NON PUT /path M:0x92 T:0xd1 RT=12 QB1:1/1/1024
         +--------->| NON PUT /path M:0x93 T:0xd2 RT=12 QB1:2/0/1024
         |   ...    |
      [[NON_RECEIVE_TIMEOUT (server) delay expires]]
         |     [[The server realizes a block is missing and asks
         |        for the missing one.  Retry #1]]            
         |<---------+ NON 4.08 M:0x01 T:0xd2 [Missing 1]
         |   ...    |
      [[2 * NON_RECEIVE_TIMEOUT (server) delay expires]]
         |     [[The server realizes a block is still missing and asks
         |        for the missing one.  Retry #2]]            
         |<---------+ NON 4.08 M:0x02 T:0xd2 [Missing 1]
         |   ...    |
      [[4 * NON_RECEIVE_TIMEOUT (server) delay expires]]
         |     [[The server realizes a block is still missing and asks
         |        for the missing one.  Retry #3]]            
         |<---------+ NON 4.08 M:0x03 T:0xd2 [Missing 1]
         |   ...    |
      [[8 * NON_RECEIVE_TIMEOUT (server) delay expires]]
         |     [[The server realizes a block is still missing and asks
         |        for the missing one.  Retry #4]]            
         |<---------+ NON 4.08 M:0x04 T:0xd2 [Missing 1]
         |   ...    |
      [[16 * NON_RECEIVE_TIMEOUT (server) delay expires]]
         |     [[NON_MAX_RETRANSMIT exceeded. Server stops requesting
         |       for missing blocks and releases partial body]]
         |   ...    |
]]></artwork>
            </figure></t>
        </section>
      </section>

      <section title="Q-Block2 Option">
        <t>These examples include the Observe Option to demonstrate how that
        option is used. Note that the Observe Option is not required for
        Q-Block2; the observe detail can thus be ignored.</t>

        <section title="A Simple Example">
          <t><xref target="nonb4"></xref> illustrates the example of Q-Block2
          Option. The client sends a NON GET carrying Observe and Q-Block2
          Options. The Q-Block2 Option indicates a block size hint (1024
          bytes). This request is replied to by the server using four (4)
          blocks that are transmitted to the client without any loss. Each of
          these blocks carries a Q-Block2 Option. The same process is repeated
          when an Observe is triggered, but no loss is experienced by any of
          the notification blocks.</t>

          <t><figure anchor="nonb4"
              title="Example of NON Notifications with Q-Block2 Option (Without Loss)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| NON GET /path M:0x01 T:0xc0 O:0 QB2:0/1/1024
         |<---------+ NON 2.05 M:0xf1 T:0xc0 O:1220 ET=19 QB2:0/1/1024
         |<---------+ NON 2.05 M:0xf2 T:0xc0 O:1220 ET=19 QB2:1/1/1024
         |<---------+ NON 2.05 M:0xf3 T:0xc0 O:1220 ET=19 QB2:2/1/1024
         |<---------+ NON 2.05 M:0xf4 T:0xc0 O:1220 ET=19 QB2:3/0/1024
         |   ...    |
         |     [[Observe triggered]]
         |<---------+ NON 2.05 M:0xf5 T:0xc0 O:1221 ET=20 QB2:0/1/1024
         |<---------+ NON 2.05 M:0xf6 T:0xc0 O:1221 ET=20 QB2:1/1/1024
         |<---------+ NON 2.05 M:0xf7 T:0xc0 O:1221 ET=20 QB2:2/1/1024
         |<---------+ NON 2.05 M:0xf8 T:0xc0 O:1221 ET=20 QB2:3/0/1024
         |   ...    |

]]></artwork>
            </figure></t>
        </section>

        <section title="Handling MAX_PAYLOADS Limits">
          <t><xref target="nonb40"></xref> illustrates the same as <xref
          target="nonb4"></xref> but this time has eleven (11) payloads which
          exceeds MAX_PAYLOADS. There is no loss experienced.</t>

          <t><figure anchor="nonb40"
              title="Example of NON Notifications with Q-Block2 Option (Without Loss)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| NON GET /path M:0x01 T:0xf0 O:0 QB2:0/1/1024
         |<---------+ NON 2.05 M:0x81 T:0xf0 O:1234 ET=21 QB2:0/1/1024
         |<---------+ NON 2.05 M:0x82 T:0xf0 O:1234 ET=21 QB2:1/1/1024
         |<---------+ [[Payloads 3 - 9 not detailed]]
         |<---------+ NON 2.05 M:0x8a T:0xf0 O:1234 ET=21 QB2:9/1/1024
      [[MAX_PAYLOADS has been reached]]
         |     [[MAX_PAYLOADS blocks acknowledged by client using
         |       'Continue' Q-Block2]]
         +--------->| NON GET /path M:0x02 T:0xf1 QB2:10/1/1024
         |<---------+ NON 2.05 M:0x8b T:0xf0 O:1234 ET=21 QB2:10/0/1024
         |   ...    |
         |     [[Observe triggered]]
         |<---------+ NON 2.05 M:0x91 T:0xf0 O:1235 ET=22 QB2:0/1/1024
         |<---------+ NON 2.05 M:0x92 T:0xf0 O:1235 ET=22 QB2:1/1/1024
         |<---------+ [[Payloads 3 - 9 not detailed]]
         |<---------+ NON 2.05 M:0x9a T:0xf0 O:1235 ET=22 QB2:9/1/1024
      [[MAX_PAYLOADS has been reached]]
         |     [[MAX_PAYLOADS blocks acknowledged by client using
         |       'Continue' Q-Block2]]
         +--------->| NON GET /path M:0x03 T:0xf2 QB2:10/1/1024
         |<---------+ NON 2.05 M:0x9b T:0xf0 O:1235 ET=22 QB2:10/0/1024
      [[Body has been received]]
         |   ...    |

]]></artwork>
            </figure></t>
        </section>

        <section title="Handling MAX_PAYLOADS with Recovery">
          <t><xref target="nonb41"></xref> shows the example of an Observe
          that is triggered but for which some notification blocks are lost.
          The client detects the missing blocks and requests their
          retransmission. It does so by indicating the blocks that are missing
          as one or more Q-Block2 Options.</t>

          <t><figure anchor="nonb41"
              title="Example of NON Notifications with Q-Block2 Option (Blocks Recovery)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |   ...    |
         |     [[Observe triggered]]
         |<---------+ NON 2.05 M:0xa1 T:0xf0 O:1236 ET=23 QB2:0/1/1024
         |     X<---+ NON 2.05 M:0xa2 T:0xf0 O:1236 ET=23 QB2:1/1/1024
         |<---------+ [[Payloads 3 - 9 not detailed]]
         |     X<---+ NON 2.05 M:0xaa T:0xf0 O:1236 ET=23 QB2:9/1/1024
      [[MAX_PAYLOADS has been reached]]
         |   ...    |
      [[NON_TIMEOUT (server) delay expires]]
         |     [[Server sends next set of payloads]]
         |<---------+ NON 2.05 M:0xab T:0xf0 O:1236 ET=23 QB2:10/0/1024
         |   ...    |
      [[NON_RECEIVE_TIMEOUT (client) delay expires]]
         |     [[Client realizes blocks are missing and asks for the
         |       missing ones in one go]]
         +--------->| NON GET /path M:0x04 T:0xf3 QB2:1/0/1024\
         |          |                             QB2:9/0/1024
         |     X<---+ NON 2.05 M:0xac T:0xf3 ET=23 QB2:1/1/1024
         |<---------+ NON 2.05 M:0xad T:0xf3 ET=23 QB2:9/1/1024
         |   ...    |
      [[NON_RECEIVE_TIMEOUT (client) delay expires]]
         |     [[Client realizes block is still missing and asks for
         |       missing block]]
         +--------->| NON GET /path M:0x05 T:0xf4 QB2:1/0/1024
         |<---------+ NON 2.05 M:0xae T:0xf4 ET=23 QB2:1/1/1024
      [[Body has been received]]
         |   ...    |
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling Recovery using M-bit Set">
          <t><xref target="nonb411"></xref> shows the example of an Observe
          that is triggered but only the first two notification blocks reach
          the client. In order to retrieve the missing blocks, the client
          sends a request with a single Q-Block2 Option with the M bit
          set.</t>

          <t><figure anchor="nonb411"
              title="Example of NON Notifications with Q-Block2 Option (Blocks Recovery with M bit Set)">
              <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |   ...    |
         |     [[Observe triggered]]
         |<---------+ NON 2.05 M:0xb1 T:0xf0 O:1237 ET=24 QB2:0/1/1024
         |<---------+ NON 2.05 M:0xb2 T:0xf0 O:1237 ET=24 QB2:1/1/1024
         |     X<---+ NON 2.05 M:0xb3 T:0xf0 O:1237 ET=24 QB2:2/1/1024
         |     X<---+ [[Payloads 4 - 9 not detailed]]
         |     X<---+ NON 2.05 M:0xb9 T:0xf0 O:1237 ET=24 QB2:9/1/1024
      [[MAX_PAYLOADS has been reached]]
         |   ...    |
      [[NON_TIMEOUT (server) delay expires]]
         |     [[Server sends next set of payloads]]
         |     X<---+ NON 2.05 M:0xba T:0xf0 O:1237 ET=24 QB2:10/0/1024
         |   ...    |
      [[NON_RECEIVE_TIMEOUT (client) delay expires]]
         |     [[Client realizes blocks are missing and asks for the
         |       missing ones in one go by setting the M bit]]
         +--------->| NON GET /path M:0x06 T:0xf5 QB2:2/1/1024
         |<---------+ NON 2.05 M:0xbb T:0xf5 ET=24 QB2:2/1/1024
         |<---------+ [[Payloads 3 - 9 not detailed]]
         |<---------+ NON 2.05 M:0xc2 T:0xf5 ET=24 QB2:9/1/1024
      [[MAX_PAYLOADS has been reached]]
         |     [[MAX_PAYLOADS acknowledged by client using 'Continue'
         |       Q-Block2]]
         +--------->| NON GET /path M:0x87 T:0xf6 QB2:10/1/1024
         |<---------+ NON 2.05 M:0xc3 T:0xf0 O:1237 ET=24 QB2:10/0/1024
      [[Body has been received]]
         |   ...    |

]]></artwork>
            </figure></t>
        </section>
      </section>

      <section title="Q-Block1 and Q-Block2 Options">
        <section title="A Simple Example">
          <t><xref target="b12non"></xref> illustrates the example of a FETCH
          using both Q-Block1 and Q-Block2 Options along with an Observe
          Option. No loss is experienced.</t>

          <t><figure anchor="b12non"
              title="Example of NON FETCH with Q-Block1 and Q-Block2 Options (Without Loss)">
              <artwork><![CDATA[      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON FETCH /path M:0x10 T:0x90 O:0 RT=30 QB1:0/1/1024
       +--------->| NON FETCH /path M:0x11 T:0x91 O:0 RT=30 QB1:1/1/1024
       +--------->| NON FETCH /path M:0x12 T:0x93 O:0 RT=30 QB1:2/0/1024
       |<---------+ NON 2.05 M:0x60 T:0x93 O:1320 ET=90 QB2:0/1/1024
       |<---------+ NON 2.05 M:0x61 T:0x93 O:1320 ET=90 QB2:1/1/1024
       |<---------+ NON 2.05 M:0x62 T:0x93 O:1320 ET=90 QB2:2/1/1024
       |<---------+ NON 2.05 M:0x63 T:0x93 O:1320 ET=90 QB2:3/0/1024
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ NON 2.05 M:0x64 T:0x93 O:1321 ET=91 QB2:0/1/1024
       |<---------+ NON 2.05 M:0x65 T:0x93 O:1321 ET=91 QB2:1/1/1024
       |<---------+ NON 2.05 M:0x66 T:0x93 O:1321 ET=91 QB2:2/1/1024
       |<---------+ NON 2.05 M:0x67 T:0x93 O:1321 ET=91 QB2:3/0/1024
       |   ...    |

]]></artwork>
            </figure></t>
        </section>

        <section title="Handling MAX_PAYLOADS Limits">
          <t><xref target="b12non0"></xref> illustrates the same as <xref
          target="b12non"></xref> but this time has eleven (11) payloads in
          both directions which exceeds MAX_PAYLOADS. There is no loss
          experienced.</t>

          <t><figure anchor="b12non0"
              title="Example of NON FETCH with Q-Block1 and Q-Block2 Options (Without Loss)">
              <artwork><![CDATA[     CoAP        CoAP
    Client      Server
      |          |
      +--------->| NON FETCH /path M:0x30 T:0xa0 O:0 RT=10 QB1:0/1/1024
      +--------->| NON FETCH /path M:0x31 T:0xa1 O:0 RT=10 QB1:1/1/1024
      +--------->| [[Payloads 3 - 9 not detailed]]
      +--------->| NON FETCH /path M:0x39 T:0xa9 O:0 RT=10 QB1:9/1/1024
   [[MAX_PAYLOADS has been reached]]
      |     [[MAX_PAYLOADS blocks receipt acknowledged by server]]
      |<---------+ NON 2.31 M:0x80 T:0xa9
      +--------->| NON FETCH /path M:0x3a T:0xaa O:0 RT=10 QB1:10/0/1024
      |<---------+ NON 2.05 M:0x81 T:0xaa O:1334 ET=21 QB2:0/1/1024
      |<---------+ NON 2.05 M:0x82 T:0xaa O:1334 ET=21 QB2:1/1/1024
      |<---------+ [[Payloads 3 - 9 not detailed]]
      |<---------+ NON 2.05 M:0x8a T:0xaa O:1334 ET=21 QB2:9/1/1024
   [[MAX_PAYLOADS has been reached]]
      |     [[MAX_PAYLOADS blocks acknowledged by client using
      |       'Continue' Q-Block2]]
      +--------->| NON FETCH /path M:0x3b T:0xab QB2:10/1/1024
      |<---------+ NON 2.05 M:0x8b T:0xaa O:1334 ET=21 QB2:10/0/1024
      |   ...    |
      |     [[Observe triggered]]
      |<---------+ NON 2.05 M:0x8c T:0xaa O:1335 ET=22 QB2:0/1/1024
      |<---------+ NON 2.05 M:0x8d T:0xaa O:1335 ET=22 QB2:1/1/1024
      |<---------+ [[Payloads 3 - 9 not detailed]]
      |<---------+ NON 2.05 M:0x95 T:0xaa O:1335 ET=22 QB2:9/1/1024
   [[MAX_PAYLOADS has been reached]]
      |     [[MAX_PAYLOADS blocks acknowledged by client using
      |       'Continue' Q-Block2]]
      +--------->| NON FETCH /path M:0x3c T:0xac QB2:10/1/1024
      |<---------+ NON 2.05 M:0x96 T:0xaa O:1335 ET=22 QB2:10/0/1024
   [[Body has been received]]
      |   ...    |
]]></artwork>
            </figure></t>
        </section>

        <section title="Handling Recovery">
          <t>Consider now a scenario where some blocks are lost in
          transmission as illustrated in <xref target="b12non1"></xref>.</t>

          <t><figure anchor="b12non1"
              title="Example of NON FETCH with Q-Block1 and Q-Block2 Options (With Loss)">
              <artwork><![CDATA[      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON FETCH /path M:0x50 T:0xc0 O:0 RT=31 QB1:0/1/1024
       +--->X     | NON FETCH /path M:0x51 T:0xc1 O:0 RT=31 QB1:1/1/1024
       +--->X     | NON FETCH /path M:0x52 T:0xc2 O:0 RT=31 QB1:2/1/1024
       +--------->| NON FETCH /path M:0x53 T:0xc3 O:0 RT=31 QB1:3/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (server) delay expires]]
]]></artwork>
            </figure></t>

          <t>The server realizes that some blocks are missing and asks for the
          missing blocks in one go (<xref target="b12non2"></xref>). It does
          so by indicating which blocks have not been received in the data
          portion of the response. The token used in the response is the token
          that was used in the last received payload. The client can then
          derive the Request-Tag by matching the token with the sent
          request.</t>

          <t><figure anchor="b12non2"
              title="Example of NON Request with Q-Block1 Option (Server Recovery)">
              <artwork><![CDATA[      CoAP        CoAP
     Client      Server
       |          |
       |<---------+ NON 4.08 M:0xa0 T:0xc3 [Missing 1,2]
       |     [[Client responds with missing payloads]]
       +--------->| NON FETCH /path M:0x54 T:0xc4 O:0 RT=31 QB1:1/1/1024
       +--------->| NON FETCH /path M:0x55 T:0xc5 O:0 RT=31 QB1:2/1/1024
       |     [[Server received FETCH body,
       |       starts transmitting response body]]
       |<---------+ NON 2.05 M:0xa1 T:0xc3 O:1236 ET=23 QB2:0/1/1024
       |     X<---+ NON 2.05 M:0xa2 T:0xc3 O:1236 ET=23 QB2:1/1/1024
       |<---------+ NON 2.05 M:0xa3 T:0xc3 O:1236 ET=23 QB2:2/1/1024
       |     X<---+ NON 2.05 M:0xa4 T:0xc3 O:1236 ET=23 QB2:3/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |          |
]]></artwork>
            </figure></t>

          <t>The client realizes that not all the payloads of the response
          have been returned. The client then asks for the missing blocks in
          one go (<xref target="b12non3"></xref>). Note that, following
          Section 2.7 of <xref target="RFC7959"></xref>, the FETCH request
          does not include the Q-Block1 or any payload.</t>

          <t><figure anchor="b12non3"
              title="Example of NON Request with Q-Block1 Option (Client Recovery)">
              <artwork><![CDATA[      CoAP        CoAP
     Client      Server
       |          |
       +--------->| NON FETCH /path M:0x56 T:0xc6 RT=31 QB2:1/0/1024\
       |          |                                     QB2:3/0/1024
       |     [[Server receives FETCH request for missing payloads,
       |       starts transmitting missing blocks]]
       |     X<---+ NON 2.05 M:0xa5 T:0xc6 ET=23 QB2:1/1/1024
       |<---------+ NON 2.05 M:0xa6 T:0xc6 ET=23 QB2:3/0/1024
       |   ...    |
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |     [[Client realizes block is still missing and asks for
       |       missing block]]
       +--------->| NON FETCH /path M:0x57 T:0xc7 RT=31 QB2:1/0/1024
       |     [[Server receives FETCH request for missing payload,
       |       starts transmitting missing block]]
       |<---------+ NON 2.05 M:0xa7 T:0xc7 ET=23 QB2:1/1/1024
    [[Body has been received]]
       |   ...    |
       |     [[Observe triggered]]
       |<---------+ NON 2.05 M:0xa8 T:0xc3 O:1337 ET=24 QB2:0/1/1024
       |     X<---+ NON 2.05 M:0xa9 T:0xc3 O:1337 ET=24 QB2:1/1/1024
       |<---------+ NON 2.05 M:0xaa T:0xc3 O:1337 ET=24 QB2:2/0/1024
    [[NON_RECEIVE_TIMEOUT (client) delay expires]]
       |     [[Client realizes block is still missing and asks for
       |       missing block]]
       +--------->| NON FETCH /path M:0x58 T:0xc8 RT=31 QB2:1/0/1024
       |     [[Server receives FETCH request for missing payload,
       |       starts transmitting missing block]]
       |<---------+ NON 2.05 M:0xa7 T:0xc8 ET=24 QB2:1/1/1024
    [[Body has been received]]
       |   ...    |
]]></artwork>
            </figure></t>
        </section>
      </section>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>Security considerations discussed in Section 7 of <xref
      target="RFC7959"></xref> should be taken into account.</t>

      <t>Security considerations discussed in Sections 11.3 and 11.4 of <xref
      target="RFC7252"></xref> should be taken into account.</t>

      <t>OSCORE provides end-to-end protection of all information that is not
      required for proxy operations and requires that a security context is
      set up (Section 3.1 of <xref target="RFC8613"></xref>). It can be
      trusted that the source endpoint is legitimate even if NoSec security
      mode is used. However, an intermediary node can modify the unprotected
      outer Q-Block1 and/or Q-Block2 Options to cause a Q-Block transfer to
      fail or keep requesting all the blocks by setting the M bit and, thus,
      causing attack amplification. As discussed in Section 12.1 of <xref
      target="RFC8613"></xref>, applications need to consider that certain
      message fields and messages types are not protected end-to-end and may
      be spoofed or manipulated. It is NOT RECOMMENDED that the NoSec security
      mode is used if the Q-Block1 and Q-Block2 Options are to be used.</t>

      <t>Security considerations related to the use of Request-Tag are
      discussed in Section 5 of <xref
      target="I-D.ietf-core-echo-request-tag"></xref>.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t><list style="hanging">
          <t hangText="RFC Editor Note:">Please replace [RFCXXXX] with the RFC
          number to be assigned to this document.</t>
        </list></t>

      <section title="CoAP Option Numbers Registry">
        <t>IANA is requested to add the following entries to the "CoAP Option
        Numbers" sub-registry <xref target="Options"></xref> defined in <xref
        target="RFC7252"></xref> within the "Constrained RESTful Environments
        (CoRE) Parameters" registry:</t>

        <t><figure align="center">
            <artwork align="center"><![CDATA[+--------+------------------+-----------+
| Number | Name             | Reference |
+========+==================+===========+
|  TBA1  | Q-Block1         | [RFCXXXX] |
|  TBA2  | Q-Block2         | [RFCXXXX] |
+--------+------------------+-----------+

Table 4: CoAP Q-Block1 and Q-Block2 Option Numbers]]></artwork>
          </figure></t>

        <t>This document suggests 19 (TBA1) and 31 (TBA2) as values to be
        assigned for the new option numbers.</t>
      </section>

      <section title="Media Type Registration">
        <t>This document requests IANA to register the
        "application/missing-blocks+cbor-seq" media type in the "Media Types"
        registry <xref target="IANA-MediaTypes"></xref>. This registration
        follows the procedures specified in <xref target="RFC6838"></xref>:
        <figure>
            <artwork><![CDATA[   Type name: application

   Subtype name: missing-blocks+cbor-seq

   Required parameters: N/A

   Optional parameters: N/A

   Encoding considerations: Must be encoded as a CBOR 
     sequence [RFC8742], as defined in Section 4 of [RFCXXXX].

   Security considerations: See Section 10 of [RFCXXXX].

   Interoperability considerations: N/A

   Published specification: [RFCXXXX]

   Applications that use this media type: Data serialization and
      deserialization. In particular, the type is used by applications
      relying upon block-wise transfers, allowing a server to specify
      non-received blocks and request for their retransmission, as 
      defined in Section 4 of [RFCXXXX].

   Fragment identifier considerations: N/A

   Additional information: N/A

   Person & email address to contact for further information: IETF,
      iesg@ietf.org

   Intended usage: COMMON

   Restrictions on usage: none

   Author: See Authors' Addresses section.

   Change controller: IESG

   Provisional registration?  No]]></artwork>
          </figure></t>
      </section>

      <section anchor="new-format" title="CoAP Content-Formats Registry">
        <t>This document requests IANA to register the following CoAP
        Content-Format for the "application/missing-blocks+cbor-seq" media
        type in the "CoAP Content-Formats" registry <xref
        target="Format"></xref>, defined in <xref target="RFC7252"></xref>,
        within the "Constrained RESTful Environments (CoRE) Parameters"
        registry:</t>

        <figure>
          <artwork><![CDATA[o  Media Type: application/missing-blocks+cbor-seq
o  Encoding: -
o  Id: TBA3
o  Reference: [RFCXXXX]]]></artwork>
        </figure>

        <t>This document suggests 272 (TBA3) as a value to be assigned for the
        new content format number.</t>
      </section>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>

      <?rfc include='reference.RFC.6838'?>

      <?rfc include='reference.RFC.7252'?>

      <?rfc include='reference.RFC.8174'?>

      <?rfc include='reference.RFC.8075'?>

      <?rfc include='reference.RFC.7959'?>

      <?rfc include='reference.RFC.7641'?>

      <?rfc include='reference.RFC.8132'?>

      <?rfc include='reference.RFC.8323'?>

      <?rfc include='reference.RFC.8613'?>

      <?rfc include='reference.RFC.8742'?>

      <?rfc include='reference.RFC.8949'?>

      <?rfc include='reference.I-D.ietf-core-echo-request-tag'?>
    </references>

    <references title="Informative References">
      <?rfc include="reference.I-D.ietf-dots-telemetry"?>

      <?rfc include='reference.RFC.8974'?>

      <?rfc include='reference.I-D.bosh-dots-quick-blocks'?>

      <?rfc include='reference.RFC.6928'?>

      <?rfc include='reference.RFC.8782'?>

      <?rfc include='reference.RFC.8610'?>

      <?rfc include='reference.RFC.7967'?>

      <reference anchor="Format"
                 target="https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#content-formats">
        <front>
          <title>CoAP Content-Formats</title>

          <author>
            <organization></organization>
          </author>

          <date />
        </front>
      </reference>

      <reference anchor="Options"
                 target="https://www.iana.org/assignments/core-parameters/core-parameters.xhtml#option-numbers">
        <front>
          <title>CoAP Option Numbers</title>

          <author>
            <organization></organization>
          </author>

          <date />
        </front>
      </reference>

      <reference anchor="IANA-MediaTypes"
                 target="https://www.iana.org/assignments/media-types">
        <front>
          <title>Media Types</title>

          <author fullname="IANA">
            <organization></organization>
          </author>

          <date />
        </front>
      </reference>
    </references>

    <section anchor="CON" title="Examples with Confirmable Messages">
      <t>The following examples assume NSTART has been increased to 3.</t>

      <t>The notations provided in <xref target="legend"></xref> are used in
      the following subsections.</t>

      <section title="Q-Block1 Option">
        <t>Let's now consider the use of Q-Block1 Option with a CON request as
        shown in <xref target="con3"></xref>. All the blocks are acknowledged
        (ACK).</t>

        <t><figure anchor="con3"
            title="Example of CON Request with Q-Block1 Option (Without Loss)">
            <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| CON PUT /path M:0x01 T:0xf0 RT=10 QB1:0/1/1024
         +--------->| CON PUT /path M:0x02 T:0xf1 RT=10 QB1:1/1/1024
         +--------->| CON PUT /path M:0x03 T:0xf2 RT=10 QB1:2/1/1024
      [[NSTART(3) limit reached]]
         |<---------+ ACK 0.00 M:0x01
         +--------->| CON PUT /path M:0x04 T:0xf3 RT=10 QB1:3/0/1024
         |<---------+ ACK 0.00 M:0x02
         |<---------+ ACK 0.00 M:0x03
         |<---------+ ACK 2.04 M:0x04
         |          |
]]></artwork>
          </figure></t>

        <t>Now, suppose that a new body of data is to be sent but with some
        blocks dropped in transmission as illustrated in <xref
        target="con32"></xref>. The client will retry sending blocks for which
        no ACK was received.</t>

        <t><figure anchor="con32"
            title="Example of CON Request with Q-Block1 Option (Blocks Recovery)">
            <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| CON PUT /path M:0x05 T:0xf4 RT=11 QB1:0/1/1024
         +--->X     | CON PUT /path M:0x06 T:0xf5 RT=11 QB1:1/1/1024
         +--->X     | CON PUT /path M:0x07 T:0xf6 RT=11 QB1:2/1/1024
      [[NSTART(3) limit reached]]
         |<---------+ ACK 0.00 M:0x05
         +--------->| CON PUT /path M:0x08 T:0xf7 RT=11 QB1:3/1/1024
         |<---------+ ACK 0.00 M:0x08
         |   ...    |
      [[ACK_TIMEOUT (client) for M:0x06 delay expires]]
         |     [[Client retransmits packet]]
         +--------->| CON PUT /path M:0x06 T:0xf5 RT=11 QB1:1/1/1024
      [[ACK_TIMEOUT (client) for M:0x07 delay expires]]
         |     [[Client retransmits packet]]
         +--->X     | CON PUT /path M:0x07 T:0xf6 RT=11 QB1:2/1/1024
         |<---------+ ACK 0.00 M:0x06
         |   ...    |
      [[ACK_TIMEOUT exponential backoff (client) delay expires]]
         |     [[Client retransmits packet]]
         +--->X     | CON PUT /path M:0x07 T:0xf6 RT=11 QB1:2/1/1024
         |   ...    |
      [[Either body transmission failure (acknowledge retry timeout)
         or successfully transmitted.]]
]]></artwork>
          </figure></t>

        <t>It is up to the implementation as to whether the application
        process stops trying to send this particular body of data on reaching
        MAX_RETRANSMIT for any payload, or separately tries to initiate the
        new transmission of the payloads that have not been acknowledged under
        these adverse traffic conditions.</t>

        <t>If there is likely to be the possibility of network transient
        losses, then the use of NON should be considered.</t>
      </section>

      <section title="Q-Block2 Option">
        <t>An example of the use of Q-Block2 Option with Confirmable messages
        is shown in <xref target="b4con"></xref>.</t>

        <t><figure align="center" anchor="b4con"
            title="Example of CON Notifications with Q-Block2 Option">
            <artwork align="center"><![CDATA[       Client      Server
         |          |
         +--------->| CON GET /path M:0x01 T:0xf0 O:0 QB2:0/1/1024
         |<---------+ ACK 2.05 M:0x01 T:0xf0 O:1234 ET=21 QB2:0/1/1024
         |<---------+ CON 2.05 M:0xe1 T:0xf0 O:1234 ET=21 QB2:1/1/1024
         |<---------+ CON 2.05 M:0xe2 T:0xf0 O:1234 ET=21 QB2:2/1/1024
         |<---------+ CON 2.05 M:0xe3 T:0xf0 O:1234 ET=21 QB2:3/0/1024
         |--------->+ ACK 0.00 M:0xe1
         |--------->+ ACK 0.00 M:0xe2
         |--------->+ ACK 0.00 M:0xe3
         |   ...    |
         |     [[Observe triggered]]
         |<---------+ CON 2.05 M:0xe4 T:0xf0 O:1235 ET=22 QB2:0/1/1024
         |<---------+ CON 2.05 M:0xe5 T:0xf0 O:1235 ET=22 QB2:1/1/1024
         |<---------+ CON 2.05 M:0xe6 T:0xf0 O:1235 ET=22 QB2:2/1/1024
      [[NSTART(3) limit reached]]
         |--------->+ ACK 0.00 M:0xe4
         |<---------+ CON 2.05 M:0xe7 T:0xf0 O:1235 ET=22 QB2:3/0/1024
         |--------->+ ACK 0.00 M:0xe5
         |--------->+ ACK 0.00 M:0xe6
         |--------->+ ACK 0.00 M:0xe7
         |   ...    |
         |     [[Observe triggered]]
         |<---------+ CON 2.05 M:0xe8 T:0xf0 O:1236 ET=23 QB2:0/1/1024
         |     X<---+ CON 2.05 M:0xe9 T:0xf0 O:1236 ET=23 QB2:1/1/1024
         |     X<---+ CON 2.05 M:0xea T:0xf0 O:1236 ET=23 QB2:2/1/1024
      [[NSTART(3) limit reached]]
         |--------->+ ACK 0.00 M:0xe8
         |<---------+ CON 2.05 M:0xeb T:0xf0 O:1236 ET=23 QB2:3/0/1024
         |--------->+ ACK 0.00 M:0xeb
         |   ...    |
      [[ACK_TIMEOUT (server) for M:0xe9 delay expires]]
         |     [[Server retransmits packet]]
         |<---------+ CON 2.05 M:0xe9 T:0xf0 O:1236 ET=23 QB2:1/1/1024
      [[ACK_TIMEOUT (server) for M:0xea delay expires]]
         |     [[Server retransmits packet]]
         |     X<---+ CON 2.05 M:0xea T:0xf0 O:1236 ET=23 QB2:2/1/1024
         |--------->+ ACK 0.00 M:0xe9
         |   ...    |
      [[ACK_TIMEOUT exponential backoff (server) delay expires]]
         |     [[Server retransmits packet]]
         |     X<---+ CON 2.05 M:0xea T:0xf0 O:1236 ET=23 QB2:2/1/1024
         |   ...    |
      [[Either body transmission failure (acknowledge retry timeout)
         or successfully transmitted.]]
]]></artwork>
          </figure></t>

        <t>It is up to the implementation as to whether the application
        process stops trying to send this particular body of data on reaching
        MAX_RETRANSMIT for any payload, or separately tries to initiate the
        new transmission of the payloads that have not been acknowledged under
        these adverse traffic conditions.</t>

        <t>If there is likely to be the possibility of network transient
        losses, then the use of NON should be considered.</t>
      </section>
    </section>

    <section anchor="REL" title="Examples with Reliable Transports">
      <t>The notations provided in <xref target="legend"></xref> are used in
      the following subsections.</t>

      <section title="Q-Block1 Option">
        <t>Let's now consider the use of Q-Block1 Option with a reliable
        transport as shown in <xref target="rel3"></xref>. There is no
        acknowledgment of packets at the CoAP layer, just the final
        result.</t>

        <t><figure anchor="rel3"
            title="Example of Reliable Request with Q-Block1 Option">
            <artwork><![CDATA[        CoAP        CoAP
       Client      Server
         |          |
         +--------->| PUT /path T:0xf0 RT=10 QB1:0/1/1024
         +--------->| PUT /path T:0xf1 RT=10 QB1:1/1/1024
         +--------->| PUT /path T:0xf2 RT=10 QB1:2/1/1024
         +--------->| PUT /path T:0xf3 RT=10 QB1:3/0/1024
         |<---------+ 2.04
         |          |
]]></artwork>
          </figure></t>

        <t>If there is likely to be the possibility of network transient
        losses, then the use of unreliable transport with NON should be
        considered.</t>
      </section>

      <section title="Q-Block2 Option">
        <t>An example of the use of Q-Block2 Option with a reliable transport
        is shown in <xref target="b4rel"></xref>.</t>

        <t><figure align="center" anchor="b4rel"
            title="Example of Notifications with Q-Block2 Option">
            <artwork align="center"><![CDATA[       Client      Server
         |          |
         +--------->| GET /path T:0xf0 O:0 QB2:0/1/1024
         |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:0/1/1024
         |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:1/1/1024
         |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:2/1/1024
         |<---------+ 2.05 T:0xf0 O:1234 ET=21 QB2:3/0/1024
         |   ...    |
         |     [[Observe triggered]]
         |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:0/1/1024
         |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:1/1/1024
         |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:2/1/1024
         |<---------+ 2.05 T:0xf0 O:1235 ET=22 QB2:3/0/1024
         |   ...    |
]]></artwork>
          </figure></t>

        <t>If there is likely to be the possibility of network transient
        losses, then the use of unreliable transport with NON should be
        considered.</t>
      </section>
    </section>

    <section numbered="false" title="Acknowledgements" toc="default">
      <t>Thanks to Achim Kraus, Jim Schaad, and Michael Richardson for their
      comments.</t>

      <t>Special thanks to Christian Ams&uuml;ss, Carsten Bormann, and Marco
      Tiloca for their suggestions and several reviews, which improved this
      specification significantly. Thanks to Francesca Palombini for the AD
      review.</t>

      <t>Some text from <xref target="RFC7959" /> is reused for readers
      convenience.</t>
    </section>
  </back>
</rfc>
